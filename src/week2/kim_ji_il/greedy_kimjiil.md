# 그리디(Greedy)

### 탐욕적(Greedy)

 즉, 그리디 알고리즘은 현재 상황에서 가장 좋은 결과를 선택해나가는 방식. 하지만, 가장 좋은 결과는 최종적인 결과 도출에 대한 최적해를 보장해주는 것은 아니다.



![logo](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1c016f84-984a-4f96-bfdd-9819bbd79565%2FGreedy-search-path.gif&blockId=abab08f0-d8b0-4b2e-894e-4aa9dc6a6005)


위와 같은 경우에도 그리디 알고리즘을 사용하여 문제를 해결하면,99를 발견하지 못한다는 한계가 있다.

----

[ 그리디 알고리즘의 조건]

    1) 탐욕 선택 속성(Greedy Choice Property)
    2) 최적 부분 구조(Optimal Substructure)

1)은 이전의 선택이 이후에 영향을 주지 않음을 의미하며, 2)는 부분 문제의 최적결과가 전체에도 그대로 적용될 수 있어야 한다는 것이다.


2)의 조건에서 우리는 Dynamic Programming을 떠올릴 수 있다.
실제로 DP에서도 이와 같은 조건이 필요하기 때문이다. 하지만 DP는 다른 조건이 다르다.
DP의 경우에는 문제가 Overlapping되기 때문에 다음에 풀 문제가 이전의 작은 문제의 결과에 영향을 받게 된다. 즉, 동일한 형식의 문제가 점점 커질 뿐, 이전의 경우에 영향을 받는다.

하지만 그리디 알고리즘은 이와 달리 영향을 받아서는 안된다. 그래야 다른 경우의 결과에 상관 없이 최적해를 구할 수 있기 때문이다.

 
그런데 위의 2가지 조건을 완전히 만족하는지, 그래서 해당 문제가 그리디 알고리즘을 사용할 수 있는 경우인지를 증명하는 것은 대부분 수학적 증명이 동반되어야한다. 다시말해 상당히 까다롭다.
그래서 보통은 테스트 케이스를 작성하여 그리디 알고리즘으로 정상 동작하는지를 알아보고 그리디가 아니라면 반례를 찾아보면서 그리디 알고리즘의 정당성을 부여한다.



 


