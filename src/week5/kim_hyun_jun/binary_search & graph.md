# Binary search
선형 자료 구조(리스트, 어레이, 스택, 큐 등)에서의 대표적인 탐색 방법으로 선형 탐색(linear search), 이분 탐색(binary search), 해싱이 있다. 그 중에서도 이분 탐색은 선형 탐색에 비해 **최악의 경우에도 시간복잡도가 더 좋아** 자주 사용되는 탐색 방법이다.

이분 탐색의 경우 이미 정렬되어 있는 배열에서 탐색 범위를 반씩 줄여 가며 찾고자 하는 값을 찾는 탐색방법이다. 절반씩 범위를 줄여 가며 찾기 때문에 O(logn)의 시간 복잡도를 가진다.

실제 코딩을 할 때 벡터같은 배열은 임의 접근이 가능하여 임의 접근이 가능한 자료구조에서는 이분탐색을 잘 하지 않는다.


# Graph

## 관련 용어
그래프는 노드와 그들을 잇는 간선으로 구성되어 있다. 그래프와 관련된 용어를 정리하면 아래와 같다.
* 경로(path): 한 노드에서 그래프의 간선을 지나 다른 노드까지 가는 길을 의미
* 사이클(cycle): 처음 노드와 마지막 노드가 같은 경로를 의미
* 트리 (tree): **사이클이 없는 연결 그래프**를 의미
* 연결 그래프(connected graph): 모든 노드간에 경로가 있는 경우를 의미
* 컴포넌트(component): 그래프의 연결된 부분

좀 더 미시적인 용어는 아래와 같다.
* 두 노드를 잇는 간선이 있을 때 두 노드를 이웃(인접한) 노드라고 한다.
* 노드의 차수(degree)는 **노드의 이웃 노드의 개수**이다. 그래서 차수의 합은 언제나 2m이다.
(변수 n을 노드의 개수, m을 간선의 개수로 본다.)

<br>

## 그래프의 표현
그래프의 크기와 알고리즘에 따라 알맞은 자료구조를 사용한다.

### 인접 리스트(adjancency list)
그래프의 각 노드 x에 대한 인접 리스트, 즉 x에서 출발하는 간선이 있는 노드의 리스트를 관리한다.
보통 베터의 배열을 만들어서 구현한다. 인접 리스트는 **주어진 노드에서 출발하여 갈 수 있는 노드**를 효율적으로 찾을 수 있다.

```cpp
vector<int> adj[n];
adj[1].push_back(2);
adj[2].push_back(3);
adj[2].push_back(4);
adj[3].push_back(4);
adj[4].push_back(1);
// 무방향 그래프의 경우 출발과 끝 노드를 바꿔서 한번 더 푸쉬해야 한다.
```

### 인접 행렬(adjancency matrix)
인접 행렬은 그래프에 포함된 간선을 나타내는 행렬이다. 인접 행렬에서는 **두 노드 사이에 간선이 있는 지**를 효율적으로 확인할 수 있다. 보통 2차원 배열을 이용해서 구현한다. 인접 행렬의 경우 원소의 개수가 n^2이기 때문에 **그래프가 크면 이 방식은 쓸 수 없다.**

<br>

## 그래프 순회
기본적으로 DFS, BFS라는 두가지 그래프 순회 알고리즘이 있다. 두 알고리즘은 모든 노드를 방문하지만 두 알고리즘의 차이는 노드를 방문하는 순서에 있다. 이 두 알고리즘은 저번주에 다루었기에 건너뛴다.

<br>

## 최단 경로
### 벨만-포드 알고리즘
시작 노드에서부터 다른 모든 노드로 가는 최단 경로를 구하는 알고리즘이다. **길이가 음수인 사이클을 포함하지 않는 모든 종류의 그래프를 처리**할 수 있다. 자세한 알고리즘은 [이 링크](https://ratsgo.github.io/data%20structure&algorithm/2017/11/27/bellmanford/)에서 확인하자.

### 다익스트라 알고리즘
다익스트라 알고리즘은 벨만-포드 알고리즘보다 좀 더 효율적이기 때문에 그래프가 큰 경우에도 사용할 수 있다는 장점이 있다. 자세한 알고리즘은 [이 링크](https://ratsgo.github.io/blog/page7/)에서 확인 하자.
